{
  "ver": "1.0.27",
  "uuid": "e5a87e01-a3c4-44ce-8b40-9cc3514b36c6",
  "importer": "effect",
  "compiledShaders": [
    {
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform mat4 cc_matViewProj;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matViewProj * pos;\n  v_uv0 = a_uv0;\n  v_color = a_color;\n  gl_Position = pos;\n}",
        "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\n#endif\nvarying vec4 v_color;\nvarying vec2 v_uv0;\nuniform sampler2D texture;\nuniform float enabledTime;\nvec2 hash(vec2 p){\n    p = vec2( dot(p,vec2(137.1,373.7)), dot(p,vec2(269.5,183.7)) );\n    return fract(sin(p)*43758.37);\n}\nfloat worley(vec2 p){\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float r = 1.;\n    for(int i=-2;i<=2;i++){\n      for(int j=-2;j<=2;j++){\n          vec2 o = hash(n+vec2(i,j));\n          o = sin(enabledTime/1000.0/2. + hash(n+vec2(i,j))*6.28)*0.5+0.5;\n          o += vec2(i,j);\n          float D1 = distance(o,f);\n          r = min(r,D1);\n      }\n    }\n    return r;\n}\nvoid mainImage( out vec4 fragColor, in vec2 uv )\n{\n    float in_Time = enabledTime/1000.0*1.;\n    float c = worley(uv + vec2(0.,-in_Time))*0.5;\n    fragColor = vec4(c);\n    c += worley(uv*2.+vec2(sin(in_Time*2.)*0.5,-in_Time*6.))*0.5;\n    fragColor = vec4(c);\n    c += (-uv.y-0.3)*0.6;\n    fragColor = vec4(c);\n    vec2 p = uv;\n    p.x *=1.5+smoothstep(-0.3,1.,uv.y)*1.5;\n    float m = smoothstep(1.,.5,length(p));\n    float c0 = smoothstep(.4,.6,m*c*3.);\n    fragColor = vec4(c0);\n    float c1 = smoothstep(.5,.52,m*c*2.);\n    fragColor = vec4(c1);\n    float c2 = smoothstep(.5,.52,m*c*1.2*(-uv.y+0.3));\n    fragColor = vec4(c2);\n    float c3 = pow(worley(uv*6.+vec2(sin(in_Time*4.)*1.,-in_Time*16.)),8.);\n          c3 = smoothstep(.98,1.,c3)*m;\n    vec3 col =vec3(1.,.4,.2)*c3;\n    col = mix(col,vec3(.95,.1,.2)*(uv.y+.8),c0);\n    col = mix(col,mix(vec3(.9,.3,.2),vec3(.9,.6,.2),-uv.y),c1);\n    col = mix(col,vec3(.9,.8,.2),c2);\n    float avgColor = dot(col, vec3(1)) / 3.0;\n    fragColor = vec4(col, avgColor * 2.0);\n}\nvoid main () {\n  vec4 colorFire = vec4 (0);\n  mainImage (colorFire, (v_uv0 - vec2 (0.5, 0.5)) * 2.0);\n  gl_FragColor = colorFire;\n  return;\n  vec4 colorTex = texture2D(texture, v_uv0);\n  colorTex *= v_color;\n  gl_FragColor = colorTex.rgba;\n}"
      },
      "glsl3": {
        "vert": "\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\nin vec2 a_uv0;\nout vec2 v_uv0;\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matViewProj * pos;\n  v_uv0 = a_uv0;\n  v_color = a_color;\n  gl_Position = pos;\n}",
        "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nin vec4 v_color;\nin vec2 v_uv0;\nuniform sampler2D texture;\nuniform eff_fire {\n  float enabledTime;\n};\nvec2 hash(vec2 p){\n    p = vec2( dot(p,vec2(137.1,373.7)), dot(p,vec2(269.5,183.7)) );\n    return fract(sin(p)*43758.37);\n}\nfloat worley(vec2 p){\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float r = 1.;\n    for(int i=-2;i<=2;i++){\n      for(int j=-2;j<=2;j++){\n          vec2 o = hash(n+vec2(i,j));\n          o = sin(enabledTime/1000.0/2. + hash(n+vec2(i,j))*6.28)*0.5+0.5;\n          o += vec2(i,j);\n          float D1 = distance(o,f);\n          r = min(r,D1);\n      }\n    }\n    return r;\n}\nvoid mainImage( out vec4 fragColor, in vec2 uv )\n{\n    float in_Time = enabledTime/1000.0*1.;\n    float c = worley(uv + vec2(0.,-in_Time))*0.5;\n    fragColor = vec4(c);\n    c += worley(uv*2.+vec2(sin(in_Time*2.)*0.5,-in_Time*6.))*0.5;\n    fragColor = vec4(c);\n    c += (-uv.y-0.3)*0.6;\n    fragColor = vec4(c);\n    vec2 p = uv;\n    p.x *=1.5+smoothstep(-0.3,1.,uv.y)*1.5;\n    float m = smoothstep(1.,.5,length(p));\n    float c0 = smoothstep(.4,.6,m*c*3.);\n    fragColor = vec4(c0);\n    float c1 = smoothstep(.5,.52,m*c*2.);\n    fragColor = vec4(c1);\n    float c2 = smoothstep(.5,.52,m*c*1.2*(-uv.y+0.3));\n    fragColor = vec4(c2);\n    float c3 = pow(worley(uv*6.+vec2(sin(in_Time*4.)*1.,-in_Time*16.)),8.);\n          c3 = smoothstep(.98,1.,c3)*m;\n    vec3 col =vec3(1.,.4,.2)*c3;\n    col = mix(col,vec3(.95,.1,.2)*(uv.y+.8),c0);\n    col = mix(col,mix(vec3(.9,.3,.2),vec3(.9,.6,.2),-uv.y),c1);\n    col = mix(col,vec3(.9,.8,.2),c2);\n    float avgColor = dot(col, vec3(1)) / 3.0;\n    fragColor = vec4(col, avgColor * 2.0);\n}\nvoid main () {\n  vec4 colorFire = vec4 (0);\n  mainImage (colorFire, (v_uv0 - vec2 (0.5, 0.5)) * 2.0);\n  gl_FragColor = colorFire;\n  return;\n  vec4 colorTex = texture (texture, v_uv0);\n  colorTex *= v_color;\n  gl_FragColor = colorTex.rgba;\n}"
      }
    }
  ],
  "subMetas": {}
}